# WIL(Weekly I Learned)
<details>
<summary>221016(MON) ~ 1023(SUN)</summary>
<div markdown="1">
<hr/>
  
##### Learned : ORM 데이터베이스 관계, 스프링을 통한 게시글 좋아요 기능 구현
##### Weekly
프론트엔드와의 협업 과제 전, 백엔드 마지막 과제를 끝냈다. 기존 CRUD, JWT로그인 구현 및 추가적으로 **좋아요기능**을 구현하는데 
  
초점을 맞췄던 한 주, 3주간의 스프링 주특기 주가 끝난만큼 앞으로 이 토대 위에 전문적이고 딥한 탐구 및 구현력을 요망📝
  
게시글 좋아요 기능을 구현하는데 있어서 유저와 게시글간 데이터베이스의 관계에 대해 이해하게 되었다.

금요일에는 드디어 처음으로 프론트엔드 팀원 분들과 팀을 이루어 미니프로젝트를 하게되었다. 팀이 구현할 주제 회의 및
  
FIGMA를 통한 와이어프레임 구성 등을 완료. 앞으로의 프로젝트들은 좀 더 흥미진진할듯 싶다🤝 

#### Keyword🔑 CORS?
  
CORS란 (Cross Origin Resource Sharing) 교차 출처 리소스 공유이다.
  
이는 일종의 정책이며, CORS 정책 위반으로 인한 에러는 개발중에 흔하게 겪게된다고 한다.
  
**SOP(Same-Origin Policy)**
  
웹 생태계에는 다른 출처로의 리소스 요청을 제한하는 것과 관련된 두 가지 정책이 존재한다. 

한 가지는 CORS, 다른 하나는 SOP이다. SOP는 보안 정책으로 "같은 출처에서만 리소스를 공유할수 있다"라는 규칙을 가진 정책이다.
  
그러나 웹이라는 오픈 스페이스 환경에서 다른 출처에 있는 리소스를 가져와서 사용하는 일은 굉장히 흔한일이다. 이를 무작정 
  
막을 수 없는 상황에서, 몇 가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했다.
  
그 중 하나가 "CORS 정책을 지킨 리소스 요청" 이다.
  
우리가 다른 출처로 리소스를 요청한다면 SOP 정책위반, 예외 조항인 CORS 정책까지 지키지 않는다면 아예 다른 출처의 리소스를 사용할 수 없게된다.
  
왜 이렇게 개발자에게 귀찮은 정책을 만들었는가? 역시 보안때문이다.
  
우리는 개발자 도구만 열어도 알 수 있듯이 대부분의 소스 코드를 직접 볼 수 있다. 
  
이처럼 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 취약한 측면이 있다. 

**같은 출처와 다른 출처의 구분**
  
사실 두 개의 출처가 서로 같다고 판단하는 로직은 굉장히 간단하다. 두 URL의 구성요소 중 Scheme, Host, Port 이 3가지만 동일하면 된다.

https://soonhankwon.github.io:80 이라는 출처를 예로 들면 https:// Scheme에 soonhankwon.github.io Host, :80번 Port를 사용하고 있다는 것만 같다면 나머지는 전부 다르더라도 같은 출처로 인정이 된다. 
 
http://soonhankwon.github.io Scheme 이 다름
  
https://api.github.io Host가 다름
  
https://soonhankwon.gitbub.io:8000 브라우저의 구현에 따라 다름(스킴, 호스트, 포트 삼중체계여야 한다)

여기서 중요한 사실 한 가지는 이렇게 출처를 비교하는 로직이 서버가 아니고 브라우저에 구현되 있는 스펙이라는 것이다.
  
따라서 우리가 CORS 정책을 위반하는 리소스 요청을 하더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 로직을 가지고 있는 경우가 아니라면 서버는 정상적으로 응답을 하고, 이후 브라우저가 응답을 분석해서 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않고 그냥 버린다. 

즉, CORS는 브라우저의 구현 스펙에 포함되는 정책이기 때문에, 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않는다. 또한 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 남기 때문에, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.
  
**CORS는 어떻게 동작하는가?**
  
그럼 본격적으로 어떤 방법을 통해 서로 다른 출처를 가진 리소스를 안전하게 사용할 수 있는지 알아보도록 하자.

기본적으로 웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.

http://soonhankwon.github.io  
  
이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 Access-Control-Allow-Origin이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

기본적인 흐름은 이렇게 간단하지만, 사실 CORS가 동작하는 방식은 한 가지가 아니라 세 가지의 시나리오에 따라 변경되기 때문에 여러분의 요청이 어떤 시나리오에 해당되는지 잘 파악한다면 CORS 정책 위반으로 인한 에러를 고치는 것이 한결 쉬울 것이다 -ing.

📝Reference

https://evan-moon.github.io/2020/05/21/about-cors/

</div>
</details>
<details>
<summary>221010(MON) ~ 1015(SUN)</summary>
<div markdown="1">
<hr/>

##### Learned : Spring CRUD, JWT, SPRING SECURITY
##### Weekly 
저번주에 진행했던 기존 CRUD에 spring **security**와 **JWT**방식을 이용한 로그인을 구현하는데 집중한 주 였다.

JWT 와 시큐리티의 인증, 인가의 복잡한 흐름이 머리속을 혼란스럽게 한다!🥶

시간이 되면 그림을 그리면서 한번 정리해볼 예정🧐

그리고 10/15 카카오 데이터 센터 화재 덕에, GITHUB로 블로그를 이전함.

마크다운 문법이 익숙하지 않지만, 역시 깃허브 쪽이 훨씬 흥미롭다.🔮
##### Keyword🔑 ORM?

**1. ORM**
(Object-Relational Mapping)

**객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다.**

객체 지향 프로그래밍은 클래스를 사용, 관계형 데이터베이스는 테이블을 사용.

▶️ 객체 모델과 관계형 모델 간의 불일치가 존재.

ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해서 불일치를 해결해준다.

Database Data **<-Mapping->** Object Field

Persistant API라고도 부른다. (JPA, Hibernate)

**2. ORM의 장, 단점**

**장점** : 객체 지향적인 코드로 인해 더 직관적이고, 비즈니스 로직에 집중할 수 있게 도와준다. 

SQL 쿼리가 아닌 직관적인 코드로 데이터를 조작할 수 있어 개발자가 객체 지향 프로그래밍하는데 도움을 준다. 

재사용성 및 유지보수의 편리성 증가

DBMS(Database Management System)에 대한 종속성이 줄어든다.

**단점** : 완벽히 ORM으로만 서비스 구현이 힘듬

사용하기는 편하지만 설계단계에서 신중해야하며, 프로젝트가 복잡해질 경우 난이도 상승

잘못 구현된 경우, 속도저하 및 일관성이 무너지는 문제점이 생길수 있다. 
</div>
</details>
